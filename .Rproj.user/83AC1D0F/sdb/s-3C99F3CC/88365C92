{
    "collab_server" : "",
    "contents" : "\n\nrequire(shiny)\nsource('f_classification_v04.R')\n\nmod_tree_UI = function(input, status, rea_ana){\n  \n  renderUI({\n    \n    validate(\n      need(status$group_stat, 'Waiting for Group Stats')\n      , need(status$imp, 'Waiting for Predictive Capacity Data')\n    )\n    \n    \n    d_clean = rea_ana()\n    categoricals = d_clean$categoricals\n    numericals   = d_clean$numericals\n    \n    inputPanel(\n      \n      selectInput(\"group_tree\"\n                  , label    = \"select predicted variable\"\n                  , choices  = c(categoricals, numericals)\n                  , selected = input$default_group\n                  \n      )\n      \n      , numericInput('min_split'\n                     ,label = 'minimum node size to attempt split'\n                     , min   = 2\n                     , max   = 10000\n                     , step  = 1\n                     , value = 20\n      )\n      \n      , numericInput('max_depth'\n                     , label = 'maximum tree depth'\n                     , min   = 2\n                     , max   = 30\n                     , step  = 1\n                     , value = 30\n      )\n      \n      , numericInput('cp'\n                     ,label = 'minimum complexity reduction to attempt split'\n                     , min   = 0.0001\n                     , max   = 0.99\n                     , step  = 0.001\n                     , value = 0.01\n      )\n      \n      , numericInput('prune'\n                     , label = 'Complexitiy(CP) Threshold for Pruning'\n                     , min   = 0\n                     , max   = 1\n                     , step  = 0.1\n                     , value = 0\n      )\n    )\n    \n  })\n  \n}\n\nmod_tree_rea = function( input, status, rea_ana ){\n  \n  reactive({\n    \n    validate(\n      need(status$group_stat, 'Waiting for Group Stats')\n      , need(status$imp, 'Waiting for Predictive Capacity Data')\n    )\n    \n    withProgress(message = 'Calculating Decision Tree'\n                 ,{\n                   \n     d_clean = rea_ana()\n    \n     categoricals = d_clean$categoricals\n     numericals   = d_clean$numericals\n     data         = d_clean$data[, c(categoricals, numericals) ]\n     \n     group_var = input$group_tree\n     n_levels  = levels( data[[input$group_tree]]) %>%\n       length()\n     \n     \n     form = stringr::str_c(group_var, '~.') %>%\n       as.formula()\n     \n     m = rpart::rpart(form\n                      , data\n                      , minsplit = input$min_split\n                      , cp       = input$cp\n                      #, maxcompete = 4\n                      #, maxsurrogate = 5\n                      #, usesurrogate = 2\n                      #, xval = 10\n                      #, surrogatestyle = 0\n                      , maxdepth = input$max_depth\n                      , xval     = 10)\n     \n     if( ! input$prune == 0){\n  \n       m = rpart::prune( m, cp = input$prune)\n     }\n     \n     data$pred_class = predict(m, data, type = 'class')\n     data$pred_prob  = predict(m, data, type = 'prob')[,n_levels]\n  \n   })\n    \n    status$tree = T\n    \n    return( list(m = m\n                 , data = data))\n    \n  })\n}\n\nmod_tree_UI_plot = function(){\n  \n  inputPanel(\n    \n    checkboxInput('fallen_leaves'\n                  , label = 'fallen_leaves'\n                  , value = T)\n    \n    , numericInput('tweak'\n                   ,label = 'increase_text_size'\n                   , min   = 0.1\n                   , max   = 10\n                   , step  = 0.1\n                   , value = 1.2\n    )\n    \n    , numericInput('gap'\n                   , label = 'gap'\n                   , min   = 0\n                   , max   = 100\n                   , step  = 1\n                   , value = 2\n    )\n    \n    , numericInput('space'\n                   , label = 'space'\n                   , min   = 0\n                   , max   = 100\n                   , step  = 1\n                   , value = 2\n    )\n    \n  )\n}\n\nmod_tree_plot = function(input, status, rea_tree){\n  \n  \n  \n  tagList(\n    \n    renderPlot({\n      \n      validate(\n        need(status$group_stat, 'Waiting for Group Stats')\n        , need(status$imp, 'Waiting for Predictive Capacity Data')\n      )\n      \n      m = rea_tree()$m\n      \n      rpart.plot::prp(m\n                      , branch.type   = 5\n                      , box.palette   =\"RdYlGn\"\n                      , faclen        = 0\n                      , extra         = 6\n                      , fallen.leaves = input$fallen_leaves\n                      , tweak         = input$tweak\n                      , gap           = input$gap\n                      , space         = input$space\n      )\n      \n      name = stringr::str_c( input$sql_or_lib,'_tree1_', input$group_tree )\n      \n      save_plot(plot = p\n                , path = input$path\n                , name = name\n                , yes = input$save\n                , excel = F\n      )\n    })\n    \n    , renderPlot({\n      \n      validate(\n        need(status$group_stat, 'Waiting for Group Stats')\n        , need(status$imp, 'Waiting for Predictive Capacity Data')\n      )\n      \n      m = rea_tree()$m\n      \n      rpart.plot::rpart.plot(m\n                             , fallen.leaves = T\n                             , tweak         = input$tweak\n                             , gap           = input$gap\n                             , space         = input$space\n      )\n      \n      name = stringr::str_c( input$sql_or_lib,'_tree2_', input$group_tree )\n      \n      save_plot(plot = p\n                , path = input$path\n                , name = name\n                , yes = input$save\n                , excel = F\n      )\n    })\n    \n  )\n  \n}\n\n\n\nmod_tree_prune_plot = function(input, rea_tree, rea_ana){\n  \n  tagList(\n    \n\n    renderPrint( print(rea_tree()$m) )\n    \n    , DT::renderDataTable({\n      \n      m_tree = rea_tree()$m\n      \n      prune_df = tibble( nsplit   = m_tree$cptable[,2]\n                         , complexity = m_tree$cptable[,1]\n                         , cv_error = m_tree$cptable[,4]\n      )\n    })\n    \n    , renderPlot({\n      \n      m_tree = rea_tree()$m\n      \n      prune_df = tibble( complexity = m_tree$cptable[,1]\n                         , cv_error = m_tree$cptable[,4]\n                         , nsplit   = m_tree$cptable[,2]) %>%\n        gather( key = 'key', value = 'value', complexity, cv_error)\n      \n      \n      \n      ggplot(prune_df, aes(x = nsplit, y = value) ) +\n        geom_line()+\n        geom_point()+\n        facet_wrap(~key, ncol = 1,scales = 'free_y')\n      \n    })\n    \n    , renderPrint({\n      \n      m         = rea_tree()$m\n      data      = rea_tree()$data\n      group_var = input$group_tree\n      \n      if( ! is.factor(data[[group_var]]) ) {\n        stop('need factor to create prediction table')\n      }\n      \n      predicted = data[['pred_class']]\n      control   = data[[group_var]]\n              \n      print(  table (predicted, control) )\n             \n      \n    })\n    \n    , renderPrint({\n      \n      m         = rea_tree()$m\n      data      = rea_tree()$data\n      group_var = input$group_tree\n      \n      if( ! is.factor(data[[group_var]]) ) {\n        stop('need factor to calculate AUC')\n      }\n      \n      if( length( levels( data[[group_var]] ) ) > 2 ){\n        stop('need binary factor to calculate AUC')\n      }\n      \n      predicted = data[['pred_prob']]\n      control   = data[[group_var]]\n      \n      paste('AUC:', f_get_rocr_auc(predicted, control) )\n      \n    })\n    \n    , renderPlot({\n      \n      m         = rea_tree()$m\n      data      = rea_tree()$data\n      group_var = input$group_tree\n      \n      if( ! is.factor(data[[group_var]]) ) {\n        stop('need factor to calculate AUC')\n      }\n      \n      if( length( levels( data[[group_var]] ) ) > 2 ){\n        stop('need binary factor to calculate AUC')\n      }\n      \n      predicted = data[['pred_prob']]\n      control   = data[[group_var]]\n      \n      f_get_rocr_auc(predicted, control, plot_rocr = T) \n    })\n  )\n\n  \n}\n\n\n\n",
    "created" : 1504847306770.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3347482772",
    "id" : "88365C92",
    "lastKnownWriteTime" : 1504761235,
    "last_content_update" : 1504761235,
    "path" : "C:/Users/erbla/OneDrive/R/multiview_som/mod_tree_v03.R",
    "project_path" : "mod_tree_v03.R",
    "properties" : {
        "docOutlineSize" : "188.60466053666244",
        "docOutlineVisible" : "1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}