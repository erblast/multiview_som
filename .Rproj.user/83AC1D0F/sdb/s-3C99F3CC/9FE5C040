{
    "collab_server" : "",
    "contents" : "\nrequire(shiny)\n\nmod_som_cluster_dist = function(rea_som){\n  \n  reactive({\n  \n    m    = rea_som()$map\n    grid = rea_som()$grid\n    \n    # fuse all layers into one dataframe\n    codes = tibble( layers = names(m$codes)\n                    ,codes = m$codes ) %>%\n      mutate( codes = purrr::map(codes, as_tibble) ) %>%\n      spread( key = layers, value = codes) %>%\n      apply(1, bind_cols) %>%\n      .[[1]] %>%\n      as_tibble()\n    \n    # generate distance matrix for codes\n    dist_m = dist(codes) %>%\n      as.matrix()\n    \n    # generate seperate distance matrix for map location\n    \n    dist_on_map = kohonen::unit.distances(grid)\n    \n    \n    #multiply euclidean distance by distance on map\n    dist_adj = dist_m ^ dist_on_map\n  \n    return(dist_adj)\n    \n  })\n}\n\n\nmod_som_cluster_opt_no_clust = function( input, rea_dist){\n  \n  tagList(\n    \n    numericInput('max_no_clust'\n                , 'Select Maximum No of Clusters'\n                , min = 2\n                , max = 100\n                , value = 15)\n    \n    , renderText('Ellbow Method')\n    \n    ,renderPlot({\n      \n      withProgress(message = 'Applying Ellbow method'\n                   ,{\n      \n        #ellbow method\n        factoextra::fviz_nbclust(rea_dist()\n                                 , factoextra::hcut\n                                 , method = \"wss\"\n                                 , hc_method = 'ward.D2'\n                                 , k.max = input$max_no_clust) \n      })\n      \n    })\n    \n    , renderText('Sillhouette Method')\n    \n    , renderPlot({\n      \n      withProgress(message = 'Applying Sillhouette method'\n                   ,{\n                     \n      #silhouette method\n      factoextra::fviz_nbclust(rea_dist()\n                               , factoextra::hcut\n                               , method = \"silhouette\"\n                               , hc_method = \"ward.D2\"\n                               , k.max =  input$max_no_clust)\n      })\n      \n    })\n  )\n  \n}\n\nmod_som_cluster_ui = function(input){\n  \n  renderUI({\n    \n    inputPanel(\n    \n    numericInput('no_clust'\n                 , 'Select No of Clusters'\n                 , min = 2\n                 , max = input$max_no_clust\n                 , value = 2)\n    \n    , actionButton('but_clust'\n                   ,'Start Clustering'\n                   )\n    \n    )\n    \n  })\n  \n}\n\nmod_som_cluster_rea = function(input\n                               , status\n                               , rea_som\n                               , rea_dist\n                               ){\n  \n  eventReactive( input$but_clust\n                 , {\n    \n    withProgress( message = 'Performing Clustering'\n                  ,{\n    \n      dist_adj      = rea_dist()\n      map           = rea_som()$map\n      grid          = rea_som()$grid\n      data          = rea_som()$data$data\n      numericals    = rea_som()$data$numericals\n      categoricals  = rea_som()$data$categoricals\n      \n      #perform hierarchical clustering\n      clust_adj = hclust(as.dist(dist_adj), 'ward.D2')\n      \n      #cut tree at desired number of clusters\n      som_cluster_adj = cutree(clust_adj, input$no_clust)\n      \n      #link cluster association to original cleaned dataframe\n      link = tibble( map_loc = names(som_cluster_adj) %>% as.integer()\n                     ,cluster = som_cluster_adj %>% as.factor() )\n      \n      pred = tibble( map_loc = map$unit.classif) %>%\n        left_join(link)\n      \n      data_pred = data %>%\n        bind_cols(pred)\n      \n      # #remove map_loc from data\n      # \n      # data_pred = data_pred %>%\n      #   select(- map_loc)\n      \n      #add cluster to categoricals\n      categoricals = c(categoricals, 'cluster')\n      \n      # we have to pack a new dataobject to pass on\n      data_new = list(data           = data_pred\n                      , numericals   = numericals\n                      , categoricals = categoricals\n      )\n      \n      som_clust = list(data = data_new\n                       , clust = som_cluster_adj\n                       , grid  = grid)\n      \n      status$clust = 'Clustering Done'\n      \n      return(som_clust)\n    \n    })\n    \n  })\n  \n  \n}\n\n\nmod_som_cluster_man_change_cluster_UI = function( input ){\n  \n  renderUI({\n  \n    inputPanel(\n      \n      numericInput('x_cord'\n                   , 'Select x Coordinate'\n                   , min   = 1\n                   , max   = input$map_dim_a\n                   , value = 1\n                   )\n      , numericInput('y_cord'\n                     , 'Select y coordinate'\n                     , min   = 1\n                     , max   = input$map_dim_b\n                     , value = 1\n                    )\n      , numericInput('assign_clust'\n                     , 'Cluster No to assign'\n                     , min   = 1\n                     , max   = input$no_clust\n                     , value = 1\n                     )\n      , actionButton( 'but_assign_clust'\n                      , 'Assign cluster to coordinate')\n    )\n  \n  })\n}\n\n\n\nmod_som_cluster_man_change_cluster_rea = function( input, status, rea_clust){\n  \n  eventReactive(input$but_assign_clust\n                ,{\n    \n    # we want the code to run when the event is initialised \n    # but not to modify any clusters\n    if( is.null( input$but_assign_clust ) ){\n      return( rea_clust() )\n    }             \n    \n    # cluster info is stored in data as sperate column in dataframe\n    # and as named int in clust, both need to be changed\n                  \n    clust_ls = rea_clust()              \n    data_ls  = clust_ls$data\n    data     = data_ls$data\n    clust    = clust_ls$clust\n    grid     = clust_ls$grid\n    \n    # for some reason maploc == 1 is the bottom left corner of the visual map\n    # we need to transform the coordinates appropriately\n    map_loc = grid$xdim * ( grid$ydim - input$y_cord ) + input$x_cord\n    \n    # we need to store cluster assignments and reapply them each time this \n    # function is called, otherwise we loose them because we always start with \n    # the freshly clustered data from rea_clust\n    \n    \n    \n    data = data %>%\n      mutate( cluster = ifelse( map_loc == map_loc, input$assign_clust, cluster ))\n    \n    clust[ map_loc ]  = input$assign_clust\n    \n    data_ls$data = data\n    \n    clust_ls$data  = data_ls\n    clust_ls$clust = clust\n    \n    return( clust_ls )\n                  \n  }, ignoreNULL = T, ignoreInit = F)\n  \n}\n\n\nmod_som_cluster_plot = function(input, rea_clust, rea_som){\n  \n  tagList(\n  \n    renderUI({\n      \n      selectInput('codes_clust'\n                  , label = 'Select Map Layer'\n                  , choices = names( rea_som()$m$codes )\n      )\n      \n    })\n    \n    \n    , renderPlot({\n      \n      map   = rea_som()$map\n      clust = rea_clust()$clust\n      whatmap = input$codes_clust\n      \n      if( length(whatmap) == 1 ){\n        whatmap = NULL\n      }\n      \n      #this code is a bit ugly, i stole it\n      #defines a color pallette\n      \n      qual_col_pals = RColorBrewer::brewer.pal.info[RColorBrewer::brewer.pal.info$category == 'qual',]\n      pallette = unlist(mapply(RColorBrewer::brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))\n      \n\n      p = plot(map\n               , type=\"codes\"\n               , main = \"Clusters\"\n               , bgcol = pallette[clust]\n               , pchs = NA\n               , whatmap = whatmap\n               , shape = 'straight'\n               )\n    \n  \n    }, width = 1024, height = 768)\n  \n  )\n}\n  \n\n\n\nmod_som_clust_2_data = function(rea_clust){\n  \n  reactive({\n    rea_clust()$data\n  })\n}\n\n\n\n\n",
    "created" : 1504803526528.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2366050907",
    "id" : "9FE5C040",
    "lastKnownWriteTime" : 1505231901,
    "last_content_update" : 1505231901390,
    "path" : "C:/Users/erbla/OneDrive/R/multiview_som/mod_som_cluster_v02.R",
    "project_path" : "mod_som_cluster_v02.R",
    "properties" : {
        "docOutlineSize" : "266.8254893141276",
        "docOutlineVisible" : "1",
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}